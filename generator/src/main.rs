use std::{collections::HashSet, path::PathBuf};

use indexmap::IndexMap;
use serde_json::{Map, Value};

const BLACKLISTED_TYPES: &[&str] = &["ProtocolMessage", "Request", "Event", "Response"];
const DYNAMIC_TYPES: &[&str] = &[
    "RestartArguments",
    "LaunchRequestArguments",
    "AttachRequestArguments",
];
const RESERVED_IDENTIFIERS: &[&str] = &["default"];

const DISCLAIMER: &str = "\
// This file is autogenerated. Do not edit by hand.
// To regenerate from schema, run `cargo run -p generator`.";
const IMPORTS: &str = "\
using System;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;

#pragma warning disable CS8603 // Possible null reference return.";
const NAMESPACE: &str = "Dap";

fn main() {
    let schema = load_schema();
    let protocol_types = generate_protocol_types(&schema);
    let types = write_types(&protocol_types);
    let requests = write_requests(&protocol_types);
    let events = write_events(&protocol_types);
    write_file("Types.cs", &types);
    write_file("Requests.cs", &requests);
    write_file("Events.cs", &events);
}

fn load_schema() -> Value {
    let workspace_dir = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap();
    let mut schema_path = workspace_dir.to_owned();
    schema_path.push("schema.json");
    let contents = std::fs::read_to_string(&schema_path).unwrap();
    serde_json::from_str(&contents).unwrap()
}

fn dst_path(file: &str) -> PathBuf {
    let workspace_dir = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap();
    let mut path = workspace_dir.to_owned();
    path.push("dap-types");
    std::fs::create_dir_all(&path).unwrap();
    path.push(file);
    path
}

fn write_file(file: &str, contents: &str) {
    std::fs::write(dst_path(file), contents).unwrap();
}

fn write_requests(types: &[ProtocolType]) -> String {
    let mut writer = Writer::default();
    writer.line(DISCLAIMER);
    writer.line(IMPORTS);
    writer.finished_object();

    writer.line(format!("namespace {NAMESPACE}"));
    writer.scoped(|writer| {
        let mut request_types = types
            .iter()
            .filter_map(|type_info| {
                if let Type::Object(obj) = &type_info.type_info {
                    if obj.base.as_deref() == Some("Request") {
                        let commands = &obj
                            .find_field("command")
                            .unwrap()
                            .type_info
                            .as_enum()
                            .variants;
                        assert_eq!(commands.len(), 1);
                        return Some((type_info.name.clone(), obj, commands[0].clone()));
                    }
                }
                None
            })
            .collect::<Vec<_>>();

        writer.line("[JsonConverter(typeof(StringEnumConverter))]");
        writer.line("public enum Command");
        writer.scoped(|writer| {
            for (_, _, command) in &mut request_types {
                writer.line(format!("[EnumMember(Value = \"{command}\")]"));
                *command = to_pascal_case(command);
                writer.line(format!("{},", command));
            }
        });
        writer.finished_object();

        write_request_types(writer, &request_types);
        writer.finished_object();

        let mut response_types = request_types;
        for (name, _, _) in &mut response_types {
            name.replace_range(name.find("Request").unwrap().., "Response");
        }
        assert_eq!(
            response_types
                .iter()
                .map(|(name, _, _)| name)
                .collect::<Vec<_>>(),
            types
                .iter()
                .filter_map(|type_info| if type_info.name.ends_with("Response") {
                    Some(&type_info.name)
                } else {
                    None
                })
                .filter(|name| !["ErrorResponse"].contains(&name.as_str()))
                .collect::<Vec<_>>()
        );

        write_response_types(writer, &response_types);
    });
    writer.output
}

fn write_request_types(writer: &mut Writer, types: &[(String, &Object, String)]) {
    writer.line("public abstract partial class Request");
    writer.scoped(|writer| {
        writer.line("private static partial Request ParseInternal(JObject message)");
        writer.scoped(|writer| {
            writer.line(format!(
                "{NAMESPACE}.Command command = message[\"command\"]?"
            ));
            writer.indented(|writer| {
                writer.line(format!(".ToObject<{NAMESPACE}.Command>()"));
                writer.line("?? throw new MissingFieldException(\"command\");");
            });
            writer.line("switch (command)");
            writer.scoped(|writer| {
                for (name, _, command) in types {
                    writer.line(format!("case {NAMESPACE}.Command.{command}:",));
                    writer.indented(|writer| {
                        writer.line(format!("return message.ToObject<{name}>();"))
                    });
                }
                writer.line("default:");
                writer.indented(|writer| {
                    writer.line(
                        "throw new ArgumentException($\"unknown request command: {command}\");",
                    )
                });
            });
        });
    });

    for (name, type_info, command) in types {
        writer.finished_object();
        let base = if let Some(args) = type_info.find_field("arguments") {
            match &args.type_info {
                Type::Any | Type::Object(_) => "GenericRequest".to_owned(),
                Type::Basic(args) => format!("Request<{args}>"),
                _ => panic!("bad arguments type for {}", name),
            }
        } else {
            "Request".to_owned()
        };
        writer.doc(type_info.doc.as_ref().unwrap());
        writer.line(format!("public sealed class {name} : {base}"));
        writer.scoped(|writer| {
            writer.line(format!(
                "public override {NAMESPACE}.Command Command => {NAMESPACE}.Command.{command};"
            ))
        });
    }
}

fn write_response_types(writer: &mut Writer, types: &[(String, &Object, String)]) {
    writer.line("public abstract partial class Response");
    writer.scoped(|writer| {
        writer.line("private static partial Response ParseInternal(JObject message)");
        writer.scoped(|writer| {
            writer.line(format!(
                "{NAMESPACE}.Command command = message[\"command\"]?"
            ));
            writer.indented(|writer| {
                writer.line(format!(".ToObject<{NAMESPACE}.Command>()"));
                writer.line("?? throw new MissingFieldException(\"command\");");
            });
            writer.line("switch (command)");
            writer.scoped(|writer| {
                for (name, _, command) in types {
                    writer.line(format!("case {NAMESPACE}.Command.{command}:"));
                    writer.indented(|writer| {
                        writer.line(format!("return message.ToObject<{name}>();"))
                    });
                }
                writer.line("default:");
                writer.indented(|writer| {
                    writer.line(
                        "throw new ArgumentException($\"unknown response command: {command}\");",
                    )
                });
            });
        });
    });

    for (name, type_info, command) in types {
        writer.finished_object();
        let base = if let Some(body) = type_info.find_field("body") {
            match &body.type_info {
                Type::Any => "GenericResponse".to_owned(),
                Type::Basic(body) => format!("Response<{body}>"),
                Type::Object(_) => format!("Response<{name}Body>"),
                _ => panic!("bad response body for {}", name),
            }
        } else {
            "Response".to_owned()
        };
        writer.doc(type_info.doc.as_ref().unwrap());
        writer.line(format!("public sealed class {name} : {base}"));
        writer.scoped(|writer| {
            writer.line(format!(
                "public override {NAMESPACE}.Command Command => {NAMESPACE}.Command.{command};"
            ))
        });
    }
}

fn write_events(types: &[ProtocolType]) -> String {
    let mut writer = Writer::default();
    writer.line(DISCLAIMER);
    writer.line(IMPORTS);
    writer.finished_object();

    writer.line(format!("namespace {NAMESPACE}"));
    writer.scoped(|writer| {
        let mut event_types = types
            .iter()
            .filter_map(|ty| {
                if let Type::Object(obj) = &ty.type_info {
                    if obj.base.as_deref() == Some("Event") {
                        let events = &obj
                            .find_field("event")
                            .unwrap()
                            .type_info
                            .as_enum()
                            .variants;
                        assert_eq!(events.len(), 1);
                        return Some((ty.name.clone(), obj, events[0].clone()));
                    }
                }
                None
            })
            .collect::<Vec<_>>();

        writer.line("[JsonConverter(typeof(StringEnumConverter))]");
        writer.line("public enum EventType");
        writer.scoped(|writer| {
            for (_, _, event) in &mut event_types {
                writer.line(format!("[EnumMember(Value = \"{event}\")]"));
                *event = to_pascal_case(event);
                writer.line(format!("{},", event));
            }
        });
        writer.finished_object();

        writer.line("public abstract partial class Event");
        writer.scoped(|writer| {
            writer.line("private static partial Event ParseInternal(JObject message)");
            writer.scoped(|writer| {
                writer.line(format!(
                    "{NAMESPACE}.EventType eventType = message[\"event\"]?"
                ));
                writer.indented(|writer| {
                    writer.line(format!(".ToObject<{NAMESPACE}.EventType>()"));
                    writer.line("?? throw new MissingFieldException(\"event\");");
                });
                writer.line("switch (eventType)");
                writer.scoped(|writer| {
                    for (ty, _, event) in &event_types {
                        writer.line(format!("case {NAMESPACE}.EventType.{event}:"));
                        writer.indented(|writer| {
                            writer.line(format!("return message.ToObject<{ty}>();"))
                        });
                    }
                    writer.line("default:");
                    writer.indented(|writer| {
                        writer.line("throw new ArgumentException($\"unknown event type: {eventType}\");")
                    });
                });
            });
        });

        for (name, type_info, event) in event_types {
            writer.finished_object();
            let event_base = if let Some(body) = type_info.find_field("body") {
                match &body.type_info {
                    Type::Any => "GenericEvent".to_owned(),
                    Type::Basic(body) => format!("Event<{body}>"),
                    Type::Object(_) => format!("Event<{name}Body>"),
                    _ => panic!("bad event body for {name}"),
                }
            } else {
                "Event".to_owned()
            };
            writer.doc(type_info.doc.as_ref().unwrap());
            writer.line(format!("public sealed class {name} : {event_base}"));
            writer.scoped(|writer| {
                writer.line(format!(
                    "public override {NAMESPACE}.EventType EventType => {NAMESPACE}.EventType.{event};"
                ))
            });
        }
    });
    writer.output
}

fn write_types(types: &[ProtocolType]) -> String {
    let mut writer = Writer::default();
    writer.line(DISCLAIMER);
    writer.line(IMPORTS);
    writer.finished_object();

    writer.line(format!("namespace {NAMESPACE}"));
    writer.scoped(|writer| {
        for ty in types {
            if ty.name.ends_with("Request") {
                continue;
            }
            println!("writing type {}", ty.name);
            if ty.name.ends_with("Response") || ty.name.ends_with("Event") {
                let Some(body) = ty.type_info.as_object().find_field("body") else {
                    continue;
                };
                match &body.type_info {
                    Type::Any => continue,
                    Type::Object(o) => {
                        let mut o = o.clone();
                        o.doc = o.doc.or(ty.type_info.doc());
                        o.write(&format!("{}Body", ty.name), writer);
                    }
                    Type::Basic(_) => continue,
                    _ => panic!(),
                }
            } else {
                ty.write(writer);
            }
        }
        writer.finished_object = false;
    });
    writer.output
}

fn generate_protocol_types(schema: &Value) -> Vec<ProtocolType> {
    let defs = schema.get("definitions").unwrap().as_object().unwrap();
    let mut types = Vec::new();
    for (name, def) in defs {
        if BLACKLISTED_TYPES.contains(&name.as_str()) || DYNAMIC_TYPES.contains(&name.as_str()) {
            continue;
        }
        println!("generating {name}");
        types.push(ProtocolType {
            name: name.to_owned(),
            type_info: translate_type(defs, def),
        });
    }
    types
}

fn translate_all_of(defs: &Map<String, Value>, def: &Value) -> Object {
    assert_eq!(def.as_object().unwrap().len(), 1);
    let members = def.get("allOf").unwrap().as_array().unwrap();
    let mut base = None;
    let mut doc = None;
    let mut fields = IndexMap::new();
    for mut subobject in members {
        if let Some(r) = subobject.get("$ref") {
            let rf = r
                .as_str()
                .unwrap()
                .strip_prefix("#/definitions/")
                .unwrap()
                .to_string();
            if rf.ends_with("Request") || rf.ends_with("Response") || rf.ends_with("Event") {
                assert_eq!(base, None);
                base = Some(rf);
                continue;
            } else {
                subobject = defs.get(&rf).unwrap()
            }
        }

        let subobject = translate_object(defs, subobject);
        for f in subobject.fields {
            fields.insert(f.name.clone(), f);
        }
        doc = subobject.doc.or(doc);
    }
    Object {
        base,
        doc,
        fields: fields.into_iter().map(|x| x.1).collect(),
    }
}

fn translate_object(defs: &Map<String, Value>, def: &Value) -> Object {
    assert_eq!(
        def.get("type")
            .expect("has type")
            .as_str()
            .expect("type is string"),
        "object"
    );
    let required = def
        .get("required")
        .map(|r| {
            r.as_array()
                .unwrap()
                .iter()
                .map(|x| x.as_str().unwrap())
                .collect::<HashSet<&str>>()
        })
        .unwrap_or_default();
    let mut fields = IndexMap::new();
    if let Some(properties) = def.get("properties") {
        for (name, field) in properties.as_object().unwrap().iter() {
            let field = generate_field(defs, name, field, required.contains(name.as_str()));
            fields.insert(name.to_owned(), field);
        }
    }
    Object {
        base: None,
        doc: def
            .get("description")
            .map(|x| x.as_str().unwrap().to_owned()),
        fields: fields.into_iter().map(|x| x.1).collect(),
    }
}

fn generate_field(defs: &Map<String, Value>, name: &str, def: &Value, required: bool) -> Field {
    let ty = translate_type(defs, def);
    Field {
        doc: def
            .get("description")
            .map(|x| x.as_str().unwrap().to_owned()),
        name: name.to_owned(),
        type_info: ty,
        required,
    }
}

fn translate_type(defs: &Map<String, Value>, t: &Value) -> Type {
    if is_any(t) {
        return Type::Any;
    }
    if is_enum_of(t, ["string", "null"]) {
        return "string".into();
    }
    if is_enum_of(t, ["integer", "string"]) {
        return "string".into();
    }
    if let Some(r) = t.get("$ref") {
        let r = r.as_str().unwrap().strip_prefix("#/definitions/").unwrap();
        return if DYNAMIC_TYPES.contains(&r) {
            Type::Any
        } else {
            let rf = defs.get(r).unwrap();
            // Need to unpack inexhaustive enums as their raw type.
            if rf.get("_enum").is_some() {
                translate_type(defs, rf)
            } else {
                r.into()
            }
        };
    }
    if t.get("allOf").is_some() {
        return Type::Object(translate_all_of(defs, t));
    }
    let ty = t.get("type").and_then(|x| x.as_str()).unwrap_or_else(|| {
        panic!("failed to find type on {}", t);
    });
    match ty {
        "integer" => "ulong".into(),
        "number" => "double".into(),
        "boolean" => "bool".into(),
        "string" => {
            let doc = t.get("description").map(|x| x.as_str().unwrap().to_owned());
            let variant_descriptions = t.get("enumDescriptions").map(|x| {
                x.as_array()
                    .unwrap()
                    .iter()
                    .map(|x| x.as_str().unwrap().to_owned())
                    .collect::<Vec<_>>()
            });
            if let Some(values) = t.get("enum") {
                Type::Enum(Enum {
                    doc,
                    variants: values
                        .as_array()
                        .unwrap()
                        .iter()
                        .map(|v| v.as_str().unwrap().to_owned())
                        .collect(),
                    variant_descriptions,
                })
            } else {
                "string".into()
            }
        }
        "object" => {
            if t.get("properties").is_none() && t.get("additionalProperties").is_some() {
                Type::Any
            } else {
                Type::Object(translate_object(defs, t))
            }
        }
        "array" => {
            let item = translate_type(defs, t.get("items").unwrap());
            Type::Vec(Box::new(item))
        }
        other => other.into(),
    }
}

fn is_any(t: &Value) -> bool {
    is_enum_of(
        t,
        [
            "array", "boolean", "integer", "null", "number", "object", "string",
        ],
    )
}

fn is_enum_of<const N: usize>(t: &Value, values: [&str; N]) -> bool {
    let Some(arr) = t.get("type").and_then(|x| x.as_array()) else {
        return false;
    };
    if arr.len() != values.len() {
        return false;
    }
    arr.iter().zip(values).all(|(a, b)| a == b)
}

fn to_pascal_case(raw: &str) -> String {
    words(raw)
        .into_iter()
        .map(|w| {
            w.chars()
                .take(1)
                .flat_map(|c| c.to_uppercase())
                .chain(w.chars().skip(1))
                .collect::<String>()
        })
        .collect()
}

fn words(raw: &str) -> Vec<String> {
    let mut result = Vec::new();
    let mut last = String::new();
    let mut prev_upper = false;
    for c in raw.chars() {
        if c == '_' || c == ' ' {
            result.push(std::mem::take(&mut last));
        } else if c.is_uppercase() && !prev_upper {
            result.push(std::mem::take(&mut last));
            last.extend(c.to_lowercase());
        } else {
            last.extend(c.to_lowercase());
        }
        prev_upper = c.is_uppercase();
    }
    result.push(last);
    result.retain(|x| !x.is_empty());
    result
}

#[derive(Default)]
struct Writer {
    output: String,
    indent: u8,
    finished_object: bool,
}

impl Writer {
    fn check_finish(&mut self) {
        if self.finished_object {
            self.output.push_str("\n");
            self.finished_object = false;
        }
    }

    fn line(&mut self, line: impl AsRef<str>) {
        self.check_finish();
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
        self.output.push_str(line.as_ref().trim_end());
        self.output.push_str("\n");
    }

    fn indented(&mut self, action: impl FnOnce(&mut Self)) {
        self.indent += 1;
        action(self);
        self.indent -= 1;
    }

    fn scoped(&mut self, action: impl FnOnce(&mut Self)) {
        self.line("{");
        self.indented(action);
        self.line("}");
    }

    fn finished_object(&mut self) {
        self.finished_object = true;
    }

    fn doc(&mut self, doc: impl AsRef<str>) {
        self.line("/// <summary>");
        for (i, line) in doc.as_ref().lines().enumerate() {
            if i > 0 {
                self.line("/// <br/>")
            }
            if !line.is_empty() {
                self.line(format!("/// {line}"));
            }
        }
        self.line("/// </summary>");
    }
}

struct ProtocolType {
    name: String,
    type_info: Type,
}

#[derive(Clone)]
enum Type {
    Any,
    Basic(String),
    Enum(Enum),
    Object(Object),
    Vec(Box<Type>),
}

impl Type {
    #[track_caller]
    fn as_enum(&self) -> &Enum {
        match self {
            Type::Enum(e) => e,
            _ => panic!("not an enum"),
        }
    }

    #[track_caller]
    fn as_object(&self) -> &Object {
        match self {
            Type::Object(o) => o,
            _ => panic!("not an object"),
        }
    }

    fn doc(&self) -> Option<String> {
        match self {
            Type::Any | Type::Basic(_) | Type::Vec(_) => None,
            Type::Enum(x) => x.doc.clone(),
            Type::Object(x) => x.doc.clone(),
        }
    }
}

impl From<&str> for Type {
    fn from(value: &str) -> Self {
        Type::Basic(value.to_owned())
    }
}

#[derive(Clone)]
struct Enum {
    doc: Option<String>,
    variants: Vec<String>,
    variant_descriptions: Option<Vec<String>>,
}

#[derive(Clone)]
struct Object {
    base: Option<String>,
    doc: Option<String>,
    fields: Vec<Field>,
}

#[derive(Clone)]
struct Field {
    doc: Option<String>,
    name: String,
    type_info: Type,
    required: bool,
}

impl ProtocolType {
    fn write(&self, dst: &mut Writer) {
        match &self.type_info {
            Type::Any => todo!(),
            Type::Basic(_) => (),
            Type::Enum(e) => e.write(&self.name, dst),
            Type::Object(o) => o.write(&self.name, dst),
            Type::Vec(_) => todo!(),
        }
    }
}

impl Object {
    fn write(&self, name: &str, dst: &mut Writer) {
        if let Some(doc) = &self.doc {
            dst.doc(&doc);
        }
        dst.line("[JsonObject]");
        let mut pending = Vec::new();
        let header = if let Some(base) = &self.base {
            format!("class {name} : {base}")
        } else {
            format!("struct {name}")
        };
        if self.fields.is_empty() {
            dst.line(format!("public {header} {{ }}"));
        } else {
            dst.line(format!("public {header}"));
            dst.scoped(|dst| {
                for field in &self.fields {
                    let inline_name = format!("{}{}", name, to_pascal_case(&field.name));
                    let mut ty = field.type_info.stringify(inline_name, &mut pending);
                    if let Some(doc) = &field.doc {
                        dst.doc(doc);
                    }
                    if !field.required {
                        ty.push('?');
                    }
                    if RESERVED_IDENTIFIERS.contains(&field.name.as_str()) {
                        dst.line(format!("[JsonProperty(\"{}\")]", field.name));
                        dst.line(format!("public {} @{};", ty, field.name));
                    } else {
                        dst.line(format!("public {} {};", ty, field.name));
                    }
                }
            });
        }
        dst.finished_object();
        for p in pending {
            p.write(dst);
        }
    }

    fn find_field(&self, name: &str) -> Option<&Field> {
        self.fields.iter().find(|f| f.name == name)
    }
}

impl Enum {
    fn write(&self, name: &str, dst: &mut Writer) {
        if let Some(doc) = &self.doc {
            dst.doc(doc);
        }
        dst.line("[JsonConverter(typeof(StringEnumConverter))]");
        dst.line(format!("public enum {}", name));
        dst.scoped(|dst| {
            for (i, value) in self.variants.iter().enumerate() {
                if let Some(desc) = &self.variant_descriptions {
                    assert!(desc.len() == self.variants.len());
                    dst.doc(&desc[i]);
                }
                dst.line(format!("[EnumMember(Value = \"{value}\")]"));
                dst.line(format!("{},", to_pascal_case(value)));
            }
        });
        dst.finished_object();
    }
}

impl Type {
    fn stringify(&self, inline_name: String, pending: &mut Vec<PendingInline>) -> String {
        match self {
            Type::Any => "object".to_owned(),
            Type::Basic(x) => x.clone(),
            Type::Enum(e) => {
                pending.push(PendingInline::Enum {
                    name: inline_name.clone(),
                    e: e.clone(),
                });
                inline_name
            }
            Type::Object(o) => {
                pending.push(PendingInline::Object {
                    name: inline_name.clone(),
                    o: o.clone(),
                });
                inline_name
            }
            Type::Vec(x) => format!("{}[]", x.stringify(inline_name, pending)),
        }
    }
}

enum PendingInline {
    Enum { name: String, e: Enum },
    Object { name: String, o: Object },
}

impl PendingInline {
    fn write(&self, dst: &mut Writer) {
        match self {
            PendingInline::Enum { name, e } => {
                e.write(name, dst);
            }
            PendingInline::Object { name, o } => {
                o.write(name, dst);
            }
        }
    }
}
